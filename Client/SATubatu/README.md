# サヨナラ！

* 挫折しました
* (MilkTに)切り替えていく
* 以下、挫折までの記録


# SATubatu
*「ドーモ、ミナ＝サン、SATubatuです」*―ネオオタノシケで自己紹介をするSATubatu！なんたることか！サツバツ！
その自己紹介は、ネオクシロシにまで響き渡り、キタオオドーリのシャッタードーリをホテルに変えた！ナムサン！

## 説明

* GlueMiniSATを用いたソルバ
* Linux環境でのみ動作検証済み
  * fork と execlp さえどうにかすれば、他の環境でもたぶん動く

## GlueMiniSatのインストール

    $ # wget `https://sites.google.com/a/nabelab.org/glueminisat/のzip`
	$ unzip glueminisat-2.2.8.zip
	$ mv glueminisat-2.2.8/ /usr/local/src/
	$ cd /usr/local/src/glueminisat-2.2.8/
	$ ./build.sh
	$ ln -s /usr/local/src/glueminisat-2.2.8/binary/glueminisat-simp /usr/local/bin/glueminisat

## CNF式の構成
SATのためのCNF式の構成について述べる。
特に断りのない場合、1-Originとする。

### 前提

* 石は、`n_i(1 <= i <= N(与えられた石の個数))`で表現
* ただし、`n_{N+1}`は、敷地にある障害物
* `i`を使うと座標と被るので、`n_i`を`n`と表記することもあり。
* 敷地は、「障害物で囲われている」ことにする。
  * 敷地を拡張して、障害物を置く
* 否定は、変数の頭に`-`を付けることで表現。

### 変数
* 座標`(i,j)`に、石nがあるときにTrueとなる変数を`x_(i,j)_n`とする
* その他、後述のTseitin変換による変数もあり

### 制約
こいつらを全部andで繋げれば良い。

#### 全てのマスには、少なくとも一つ石が入る
よくある`at Least`である。

数式が使えないので辛いが、こんな感じである。

    座標(i,j)に対して and:
        石n(1<=n<=N+1)に対して or:
            x_(i,j)_n

伝わるだろうか。
将来、自分が見返しても、理解できる自信がない。

#### 全てのマスには、高々一つの石が入る。
よくある`at Most`。こんな感じ。

    座標(i,j)に対して and:
        石nから2個の石m1とm2を選ぶ全組み合わせに対して and:
            -x_(i,j)_m1 && -x_(i,j)_m2

この`at Most`や、`at Least`は非常によく出るので、
これが分かりにくい場合は、後述の参考URLに示すページを参照すると良いかも知れない。

#### 既に置かれている石がある
石というか障害物だけど。こんな感じ。

    障害物の座標(I,J)に対して and:
        x_(I,J)_n_{N+1}

これは絶対Trueにならなければならないため、このようになる。

#### 石には形があり、表裏反転とか回転操作も可能
石の定義である。プログラム上では、後述の「石の順序」と順番が逆(順序なのに)だが、一切影響しない。

予め、それぞれの石で「アンカー」を決めておき、そのアンカーを配置の基準としてすると、
石の定義は、このようになるかも知れない。

    x_(i,j)_n(1<=n<=N) -> (or(可能な操作) (and(石nのブロック) x_(i+offset, j+offset)_n))

よく分からないが、「石nのアンカーを(i,j)に配置するならば、ブロックはこの位置になる」ということである。
これを、`-P || Q`しても、残念ながらCNFにならないため、Tseitin変換を実施する。
新たな変数`a_1, a_2, a_3, ... , a_8(操作の組み合わせ)`を作り、

    a_i <=> (and(石のブロック) x_(i+offset, j+offset)_n)

とすると、最終的には、

    -x_(i,j)_n && (or(操作) a_m)

という節と、`a_m`に対して、

    (and(ブロック) (-a_m || x_offset_n)) && ((or(ブロック) -x_offset_n) || a_m)

という節を追加すれば良い。何を書いているか分からないので、どうしても暇な場合、
LaTeXで書き直すことも検討する。

#### 石には置く順序が指定される
まず、`n_1`の場合は、どこに置いても良いため、

    x_(i,j)_n1 -> (and(n1の周辺) (or(石n(1<=n<=N+1)) x_n1の周辺_n))

となる。ここで、*n1の周辺*とは、注目したブロックの4近傍のことである。
となると、「n1の全てのブロックに注目」する必要があるが、式に入れ忘れてしまった。

また、「1<=n<=N+1」は、「自分か、自分よりも石を表す数値が大きいか」であるが、
表現が面倒なため、今後は「老人」とする。「老人」に自分も含む。

この式をCNFにすると、このようになる。

    (and(n1の周辺) (-x_(i,j_n1 || (or(老人) x_(n1の周辺)_(老人)))))

これだけでも、訳が分からないが、次の`n_2`以降の場合はもっと訳がわからない。

    (x_(i,j)_m1(1<=m<N) && x_((i,j)に対するm1の周辺)_m2(m1<m2<=N)) -> (and((i,j)に対するm2の周辺) (x_(周)_m1 || (or(m2<n<=N+1) x_(周)_n)))

正直訳が分かっていないので、これが正解かどうかは不明である。これをCNF式に変換すると、こうなる。

    (and(m2の周辺) (-x_(i,j)_m1 || -x_(m1周辺)_m2 || (or(老人) x_(m2の周)_(老))))

以上。

## 参考URL

* [2015/03/23 SAT ソルバー入門 (JOI 春合宿講義)](http://semiexp.github.io/docs/introduction_sat.pdf)
* [SATソルバを使うためにCNFを作る](http://soutaro.hatenablog.com/entry/20100125/1264420334)
* [The Talos Principle – Solving puzzles using SAT solvers](https://www.preining.info/blog/2015/06/talos-principle-puzzles-sat-solvers/)
* [MiniSat入門](http://www.kl.i.is.nagoya-u.ac.jp/person/yasuhiro/minisat/minisat11.pdf)

